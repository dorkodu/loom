<?php
  namespace Loom\Weaver;

  use Loom\Logger;
  use Loom\Dependency\DependencyResolver;
  use Loom\Dependency\DependencyLocker;
  
  class KnotterGenerator
  {

    /**
     * Generates content for loom-weaver.php
     * 
     * @param array $namespaces the PSR-4 namespaces array.
     * @param array $classmap the classmap array.
     * 
     * @return string generated loom-weaver.php file content
     * @return false on failure
     **/
    public static function generate(array $namespaces, array $classmap)
    {
      $rawContent = "";
      $rawContent += <<<PHP
      <?php
    
        # loom-weaver.php @generated by Loom
      
        require "loom/Psr4Autoloader.php";
        require "loom/ClassmapAutoloader.php";
      PHP;
      
      $psr4ArrayString = self::generateNamespacesContent($namespaces);
      $psr4NamespaceAutoloadScript = <<<PHP
        # psr-4 namespace autoloading
        \$universalNamespaces = array($psr4ArrayString);
        \$psr4Autoloader = new Psr4Autoloader();
        foreach (\$universalNamespaces as \$namespace => \$path) {
          \$psr4Autoloader->addNamespace(\$namespace, \$path);
        }
        \$psr4Autoloader->register();
      PHP;
      $rawContent .= $psr4NamespaceAutoloadScript;

      $classmapArrayString = self::generateClassmapContent($classmap);
      $classmapAutoloadScript = <<<PHP
        # classmap autoloading
        \$universalClassmap = array($classmapArrayString);
        \$classmapWeaver = new ClassmapAutoloader();
        \$classmapWeaver->register(\$universalClassmap);
      PHP;
      $rawContent .= $classmapAutoloadScript;

      return $rawContent;
    }

    /**
     * Generates the contents string for $universalNamespaces array.
     * 
     * @param  $namespaces PSR-4 namespaces to generate contents of.
     * 
     * @return type
     **/
    public static function generateNamespacesContent(array $namespaces)
    {
      $nsStringsList = array();
      foreach ($namespaces as $namespace => $baseDir) {
        $namespace = str_replace('\\', '\\\\', $namespace);
        array_push($nsStringsList, "'".$namespace."' => array('$baseDir')");
      }
    
      $content = "";
      $arrayCount = count($nsStringsList);
      for ($i=0; $i < $arrayCount; $i++) {
        $content .= $nsStringsList[$i];
        if ($i !== ($arrayCount - 1)) {
          $content .= ", ";
        }
      }
    
      return $content;
    }

    /**
     * Generates the contents string for $universalClassmap array.
     * 
     * @param array $classmap the resolved classmap.
     *
     * @return string array contents
     * @return false on failure
     **/
    public static function generateClassmapContent(array $classmap)
    {
      $content = "";
      $arrayCount = count($classmap);
      for ($i=0; $i < $arrayCount; $i++) {
        $content .= "'".$classmap[$i]."'";
        if ($i !== ($arrayCount - 1)) {
          $content .= ", ";
        }
      }
    
      return $content;
    }

    /**
     * Gets the contents of the classmap autoloader script.
     * @return string script content
     **/
    public static function getClassmapAutoloaderContent()
    {
      $contents = Logger::getFileContents("ClassmapAutoloader.php");
      if (is_string($contents) && $contents !== false) {
        return $contents;
      } else return false;
    }

    /**
     * Gets the contents of the PSR-4 autoloader script.
     * @return string script content
     **/
    public static function getPsr4AutoloaderContent()
    {
      $contents = Logger::getFileContents("Psr4Autoloader.php");
      if (is_string($contents) && $contents !== false) {
        return $contents;
      } else return false;
    }
  }