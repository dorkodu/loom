<?php
  namespace Loom\Weaver;

  use Loom\Logger;
  use Loom\Dependency\DependencyResolver;
  use Loom\Dependency\DependencyLocker;
  
  class KnotterGenerator
  {
    /**
     * Generates content for loom-weaver.php
     * 
     * @param array $root the root of loom.json.
     * 
     * @return string generated loom-weaver.php file content
     * @return false on failure
     **/
    public static function generate(array $rootArray)
    {
      if (!empty($rootArray)) {

        $rawContent = "";
        $rawContent .= <<<PHP
        <?php
          
          # loom-weaver.php @generated by Loom

        PHP;

        if (array_key_exists("knotted", $rootArray)) {
          $knottedArray = $rootArray['knotted'];

          # add namespaces autoloader, if needed
          if (array_key_exists("namespaces", $knottedArray)) {
            $namespacesArray = $knottedArray['namespaces'];

            if (is_array($namespacesArray) && !empty($namespacesArray)) {
              $psr4ArrayString = self::generateNamespacesContent($namespacesArray);
              $psr4NamespaceAutoloadScript = <<<PHP

                # psr-4 namespace autoloading
                \$universalNamespaces = array($psr4ArrayString);
                \$psr4Autoloader = new Psr4Autoloader();
                foreach (\$universalNamespaces as \$namespace => \$path) {
                  \$psr4Autoloader->addNamespace(\$namespace, \$path);
                }
                \$psr4Autoloader->register();

              PHP;
              $rawContent .= $psr4NamespaceAutoloadScript;
            }
          }

          # add classmap loader, if needed
          if (array_key_exists("classmap", $knottedArray)) {
            $classmapArray = $knottedArray['classmap'];

            if (is_array($classmapArray) && !empty($classmapArray)) {
              $classmapArrayString = self::generateClassmapContent($classmapArray);
              $classmapAutoloadScript = <<<PHP
                
                # classmap autoloading
                \$universalClassmap = array($classmapArrayString);
                \$classmapWeaver = new ClassmapAutoloader();
                \$classmapWeaver->register(\$universalClassmap);
              
              PHP;
              $rawContent .= $classmapAutoloadScript;
            }
          }
        }

        return $rawContent;
      } else return false;
    }

    /**
     * Generates the contents string for $universalNamespaces array.
     * 
     * @param  $namespaces PSR-4 namespaces to generate contents of.
     * 
     * @return type
     **/
    public static function generateNamespacesContent(array $namespaces)
    {
      $nsStringsList = array();
      foreach ($namespaces as $namespace => $baseDir) {
        $namespace = str_replace('\\', '\\\\', $namespace);
        array_push($nsStringsList, "'".$namespace."' => array('$baseDir')");
      }
    
      $content = "";
      $arrayCount = count($nsStringsList);
      for ($i=0; $i < $arrayCount; $i++) {
        $content .= $nsStringsList[$i];
        if ($i !== ($arrayCount - 1)) {
          $content .= ", ";
        }
      }
    
      return $content;
    }

    /**
     * Generates the contents string for $universalClassmap array.
     * 
     * @param array $classmap the resolved classmap.
     *
     * @return string array contents
     * @return false on failure
     **/
    public static function generateClassmapContent(array $classmap)
    {
      $content = "";
      $arrayCount = count($classmap);
      for ($i=0; $i < $arrayCount; $i++) {
        $content .= "'".$classmap[$i]."'";
        if ($i !== ($arrayCount - 1)) {
          $content .= ", ";
        }
      }
    
      return $content;
    }

    /**
     * Gets the contents of the classmap autoloader script.
     * @return string script content
     **/
    public static function getClassmapAutoloaderContent()
    {
      $contents = Logger::getFileContents("ClassmapAutoloader.php");
      if (is_string($contents) && $contents !== false) {
        return $contents;
      } else return false;
    }

    /**
     * Gets the contents of the PSR-4 autoloader script.
     * @return string script content
     **/
    public static function getPsr4AutoloaderContent()
    {
      $contents = Logger::getFileContents("Psr4Autoloader.php");
      if (is_string($contents) && $contents !== false) {
        return $contents;
      } else return false;
    }
  }